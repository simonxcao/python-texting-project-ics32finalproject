<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Simon Cao &amp; David Ning
# tcao10@uci.edu
# 85427485


import tkinter as tk
from tkinter import ttk, filedialog
from Final_Profile import Post, Profile, SaveData
import ds_messenger as ms
import time
from threading import Event, Thread

# variables to add to Profile instances
USER = &#39;Billybob123&#39;
PASS = &#39;kkkookkokokokook&#39;
SERVER = &#39;168.235.86.101&#39;



class RepeatedTimer:

    &#34;&#34;&#34;Repeat `function` every `interval` seconds. Adapted from stackoverflow for stopping threading&#34;&#34;&#34;

    def __init__(self, interval, function, *args, **kwargs):
        self.interval = interval
        self.function = function
        self.args = args
        self.kwargs = kwargs
        self.start = time.time()
        self.event = Event()
        self.thread = Thread(target=self._target)
        self.thread.start()

    def _target(self):
        while not self.event.wait(self._time):
            self.function(*self.args, **self.kwargs)

    @property
    def _time(self):
        return self.interval - ((time.time() - self.start) % self.interval)

    def stop(self):
        self.event.set()
        self.thread.join()


class Body(tk.Frame):
    &#34;&#34;&#34;
    A subclass of tk.Frame that is responsible for drawing all of the widgets
    in the body portion of the root frame.
    &#34;&#34;&#34;
    def __init__(self, root, select_callback=None):
        tk.Frame.__init__(self, root)
        self.root = root
        self._select_callback = select_callback
        self._file = None

        # a list of the recipients available in the active DSU file
        self._messages = []
        self._recipient = None

        # After all initialization is complete, call the _draw method to pack the widgets
        # into the Body instance
        self._draw()


    def node_select(self, event):
        &#34;&#34;&#34;
        Method for selecting object on treeview and loading the past messages from this recipient into the text widget
        &#34;&#34;&#34;
        self.entry_editor.configure(state=&#39;normal&#39;)
        self.entry_editor.delete(0.0, &#39;end&#39;)
        self.entry_editor.insert(0.0, &#39;&#39;)

        index = int(self.posts_tree.selection()[0])
        entry = self._messages[index]
        # sets the data attribute as the name of the recipient
        self._recipient = entry

        x = SaveData()
        # gets list of message that has occurred between the user and the recipient
        mess = x.re_message_get(self._recipient, self._file)
        if mess is None:
            pass
        else:
            try:
                # loads in the texts depending on if they are the users or the recipients
                for x in mess:
                    if x[-1] == &#39;1&#39;:
                        mes = x[:-1]
                        self.entry_editor.insert(&#39;end&#39;, mes + &#39;\n&#39;, &#39;left&#39;)
                    elif x[-1] == &#39;0&#39;:
                        mes = x[:-1]
                        self.entry_editor.insert(&#39;end&#39;, mes + &#39;\n&#39;, &#39;right&#39;)
                    else:
                        pass
            except IndexError:
                pass
        # return the text widget to read only
        self.entry_editor.configure(state=&#39;disabled&#39;)


    def reset_ui(self):
        &#34;&#34;&#34;
        Method that resets the treeview and the text widget
        &#34;&#34;&#34;
        self.entry_editor.configure(state=&#39;normal&#39;)
        self.entry_editor.delete(0.0, &#39;end&#39;)
        self.entry_editor.insert(0.0, &#39;&#39;)
        self.entry_editor.configure(state=&#39;disabled&#39;)
        self._messages = []
        for item in self.posts_tree.get_children():
            self.posts_tree.delete(item)


    def set_posts(self, name: list):
        &#34;&#34;&#34;
        Method that imports all the recipients in the DSU file into the treeview accoridng to their order
        &#34;&#34;&#34;
        self._messages = name
        for i in range(len(self._messages)):
            self._insert_post_tree(i, self._messages[i])

    def get_text(self):

        &#34;&#34;&#34;
        Method that gets the message that user want to send to a recipient
        &#34;&#34;&#34;
        return self.send_stuff.get(&#39;1.0&#39;, &#39;end&#39;).rstrip()



    def set_text(self, text):
        &#34;&#34;&#34;
        Method that clears the text widget after the user clicks the send button
        &#34;&#34;&#34;
        self.send_stuff.delete(0.0, &#39;end&#39;)
        self.send_stuff.insert(0.0, text)


    def insert(self, name):
        &#34;&#34;&#34;
        Method that inserts a recipient that&#39;s added by the add button into the treeview
        &#34;&#34;&#34;
        self._messages.append(name)
        id = len(self._messages) - 1
        self._insert_post_tree(id, name)



    def _insert_post_tree(self, id, name):
        &#34;&#34;&#34;
        Method that adds to the treeview
        &#34;&#34;&#34;
        label = name
        # Since we don&#39;t have a title, we will use the first 24 characters of a
        # post entry as the identifier in the post_tree widget.
        self.posts_tree.insert(&#39;&#39;, id, id, text=label)


    def _draw(self):
        &#34;&#34;&#34;
        Call only once upon initialization to add widgets to the frame
        &#34;&#34;&#34;
        # treeview widget and frame
        posts_frame = tk.Frame(master=self, width=250)
        posts_frame.pack(fill=tk.BOTH, side=tk.LEFT)
        self.posts_tree = ttk.Treeview(posts_frame)
        self.posts_tree.bind(&#34;&lt;&lt;TreeviewSelect&gt;&gt;&#34;, self.node_select)
        self.posts_tree.pack(fill=tk.BOTH, side=tk.TOP, expand=True, padx=5, pady=5)

        entry_frame = tk.Frame(master=self, bg=&#34;&#34;)
        entry_frame.pack(fill=tk.BOTH, side=tk.TOP, expand=True)

        editor_frame = tk.Frame(master=entry_frame, bg=&#34;red&#34;)
        editor_frame.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        scroll_frame = tk.Frame(master=entry_frame, bg=&#34;blue&#34;, width=10)
        scroll_frame.pack(fill=tk.BOTH, side=tk.LEFT, expand=False)

        # disable the text widget to make it read only
        self.entry_editor = tk.Text(editor_frame, state=&#39;disabled&#39;, width=0)
        self.entry_editor.pack(fill=tk.BOTH, side=tk.LEFT, expand=True, padx=0, pady=0)

        entry_editor_scrollbar = tk.Scrollbar(master=scroll_frame, command=self.entry_editor.yview)
        self.entry_editor[&#39;yscrollcommand&#39;] = entry_editor_scrollbar.set
        entry_editor_scrollbar.pack(fill=tk.Y, side=tk.LEFT, expand=False, padx=0, pady=0)

        # configures the texts in the text widget so that we can make a text appear on the left or right
        # lines 191-192 adapted by stackoverflow on how to display text to the left or right
        self.entry_editor.tag_configure(&#34;right&#34;, justify=&#34;right&#34;)
        self.entry_editor.tag_configure(&#34;left&#34;, justify=&#34;left&#34;)

        # second text widget that is for the user to enter stuff
        entry_frame2 = tk.Frame(master=self, bg=&#34;&#34;)
        entry_frame2.pack(fill=tk.BOTH, side=tk.TOP, expand=True)

        editor_frame2 = tk.Frame(master=entry_frame2, bg=&#34;red&#34;)
        editor_frame2.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        self.send_stuff = tk.Text(master=editor_frame2, width=0)
        self.send_stuff.pack(fill=tk.BOTH, side=tk.LEFT, expand=True, padx=0, pady=0)





class Footer(tk.Frame):
    &#34;&#34;&#34;
    A subclass of tk.Frame that is responsible for drawing all of the widgets
    in the footer portion of the root frame.
    &#34;&#34;&#34;
    def __init__(self, root, send_callback=None, add_callback=None):
        tk.Frame.__init__(self, root)
        self.root = root
        # sets data attributes with the parameters
        self._send_callback = send_callback
        self._add_callback = add_callback

        # After all initialization is complete, call the _draw method to pack the widgets
        # into the Footer instance
        self._draw()


    def send_click(self):
        &#34;&#34;&#34;
        Calls the callback function specified in the send_callback class attribute, if
        available, when the send_button has been clicked.
        &#34;&#34;&#34;

        if self._send_callback is not None:
            self._send_callback()


    def add_click(self):
        &#34;&#34;&#34;
        Calls the callback function specified in the add_callback class attribute, if
        available, when the add_button widget has been clicked.
        &#34;&#34;&#34;
        if self._add_callback is not None:
            self._add_callback()


    def disable(self):
        &#34;&#34;&#34;
        Disables the send and add button if nothing is created or opened
        &#34;&#34;&#34;
        self.send_button[&#34;state&#34;] = &#34;disabled&#34;
        self.add_button[&#34;state&#34;] = &#34;disabled&#34;



    def enable(self):
        &#34;&#34;&#34;
        Enables the send and add button after a file is created or opened
        &#34;&#34;&#34;
        self.send_button[&#34;state&#34;] = &#34;active&#34;
        self.add_button[&#34;state&#34;] = &#34;active&#34;



    def _draw(self):
        &#34;&#34;&#34;
        Call only once upon initialization to add widgets to the frame
        &#34;&#34;&#34;
        # send button
        self.send_button = tk.Button(master=self, text=&#34;Send&#34;, width=20)
        self.send_button.configure(command=self.send_click)
        self.send_button.pack(fill=tk.BOTH, side=tk.RIGHT, padx=5, pady=5)

        # add user button
        self.add_button = tk.Button(master=self, text=&#34;Add User&#34;, width=10)
        self.add_button.configure(command=self.add_click)
        self.add_button.pack(fill=tk.BOTH, side=tk.LEFT, padx=5, pady=5)

        # disables the buttons
        self.disable()



class MainApp(tk.Frame):
    &#34;&#34;&#34;
    A subclass of tk.Frame that is responsible for drawing all of the widgets
    in the main portion of the root frame. Also manages all method calls for
    the Profile class.
    &#34;&#34;&#34;
    def __init__(self, root):
        tk.Frame.__init__(self, root)
        self.root = root
        self._profile_filename = None

        # Initialize a new Profile and assign it to a class attribute.
        self._current_profile = Profile()

        # After all initialization is complete, call the _draw method to pack the widgets
        # into the root frame
        self._draw()



    def new_profile(self):
        &#34;&#34;&#34;
        Creates a new DSU file when the &#39;New&#39; menu item is clicked.
        &#34;&#34;&#34;
        try:
            filename = tk.filedialog.asksaveasfile(filetypes=[(&#39;Distributed Social Profile&#39;, &#39;*.dsu&#39;)])
            self._profile_filename = filename.name
            self.body._file = self._profile_filename

            # enables the buttons
            self.footer.enable()

            self._current_profile = Profile()
            # assigns the default values to these data attributes
            self._current_profile.username = USER
            self._current_profile.password = PASS
            self._current_profile.dsuserver = SERVER
            self.body.reset_ui()

            # calls the function that automatically retrieves messages
            # creates repeatedtimer object
            rt = RepeatedTimer(2.5, self.new_msg)
            self.control = rt


        except Exception as e:
            print(e)


    def open_profile(self):
        &#34;&#34;&#34;
        Opens an existing DSU file when the &#39;Open&#39; menu item is clicked and loads the profile
        data into the UI.
        &#34;&#34;&#34;
        try:
            # reset treeview and entry widget when it is called
            self.body.reset_ui()

            filename = tk.filedialog.askopenfile(filetypes=[(&#39;Distributed Social Profile&#39;, &#39;*.dsu&#39;)])
            self._profile_filename = filename.name
            self.body._file = self._profile_filename

            # enables the buttons
            self.footer.enable()

            self._current_profile = Profile()

            x = SaveData()
            y = x.return_user_pass(self._profile_filename)
            # gets the user, pass, dsuserver from the DSU file
            self._current_profile.username = y[0]
            self._current_profile.password = y[1]
            self._current_profile.dsuserver = y[2]

            # imports the messages into the treeview
            self.body.set_posts(x.open_mes(self._profile_filename))
            # calls the function that automatically retrieves new messages
            # creates repeatedtimer object
            rt = RepeatedTimer(2.5, self.new_msg)
            self.control = rt


        except Exception as e:
            print(e)


    def save_profile(self):
        &#34;&#34;&#34;
        Method that sends the direct message once the send button is clicked and also saves it to the dsu file
        &#34;&#34;&#34;
        # makes sure user can&#39;t send in empty messages or whitespaces
        if len(self.body.get_text()) == 0 or self.body.get_text().isspace() is True:
            pass
        else:
            # makes sure a user selected a recipient to talk to
            if self.body._recipient is None:
                print(&#39;select user to talk to&#39;)
            else:
                message = self.body.get_text()

                # creates instances of the classes
                exchange = ms.DirectMessage(self.body._recipient, message)
                more = ms.DirectMessenger(self._current_profile.dsuserver, self._current_profile.username,
                                          self._current_profile.password)
                # makes sure the send method worked
                if more.send(exchange.message, exchange.recipient) is True:

                    # inserts the text into the read only text widget once the send button is clicked
                    self.body.set_text(&#34;&#34;)
                    self.body.entry_editor.configure(state=&#39;normal&#39;)
                    self.body.entry_editor.insert(&#39;end&#39;, message + &#39;\n&#39;, &#39;right&#39;)
                    self.body.entry_editor.configure(state=&#39;disabled&#39;)

                    # stores the text into the DSU file
                    message = message + &#39;0&#39;
                    x = SaveData()
                    x.save_into_dsu(self._current_profile.username, message, self.body._recipient,
                                    self._current_profile.password, self._current_profile.dsuserver,
                                    self._profile_filename)
                    self.body.set_text(&#34;&#34;)
                else:
                    print(&#39;issue occurred with server or network&#39;)


    def new_msg(self):
        &#34;&#34;&#34;
        Method that keeps connecting to the server every 3 seconds to receive new messages that might be sent
        &#34;&#34;&#34;
        try:
            exchange = ms.DirectMessenger(self._current_profile.dsuserver, self._current_profile.username,
                                          self._current_profile.password)
            # gets list of all new messages
            list1 = exchange.retrieve_new()

            # makes sure there is new messages
            if len(list1) &gt; 0:
                for x in list1:
                    # checks if the user has clicked on a treeview item yet
                    if self.body._recipient is not None:

                        # checks if the message that&#39;s sent is from the recipient they clicked on
                        if x[&#39;from&#39;] == self.body._recipient:
                            # inserts the message to the read only text widget
                            self.body.entry_editor.configure(state=&#39;normal&#39;)
                            self.body.entry_editor.insert(&#39;end&#39;, x[&#39;message&#39;] + &#39;\n&#39;, &#39;left&#39;)
                            self.body.entry_editor.configure(state=&#39;disabled&#39;)
                            # saves message to the DSU file
                            message = x[&#39;message&#39;] + &#39;1&#39;
                            x = SaveData()
                            x.save_into_dsu(self._current_profile.username, message, self.body._recipient,
                                            self._current_profile.password, self._current_profile.dsuserver,
                                            self._profile_filename)
                        # if the message that&#39;s sent is not from the recipient they clicked on
                        else:
                            message = x[&#39;message&#39;] + &#39;1&#39;
                            l = x[&#39;from&#39;]
                            x = SaveData()
                            x.save_into_dsu(self._current_profile.username, message, l,
                                            self._current_profile.password, self._current_profile.dsuserver,
                                            self._profile_filename)
                    # if the user has not clicked on a recipient yet
                    else:
                        message = x[&#39;message&#39;] + &#39;1&#39;
                        l = x[&#39;from&#39;]
                        x = SaveData()
                        x.save_into_dsu(self._current_profile.username, message, l,
                                        self._current_profile.password, self._current_profile.dsuserver,
                                        self._profile_filename)

            else:
                pass
        except:
            print(&#39;Something occurred with the server and network&#39;)



    def close(self):
        &#34;&#34;&#34;
        Closes the program when the &#39;Close&#39; menu item is clicked.
        &#34;&#34;&#34;
        self.root.destroy()
        self.control.stop()


    def add(self):
        &#34;&#34;&#34;
        Method that runs when the add button is clicked
        &#34;&#34;&#34;
        # add user to the tree
        top = tk.Toplevel()
        top.title(&#39;Add User&#39;)
        user = tk.Label(top, text=&#34;Add Contact:&#34;)
        user.pack(fill=tk.BOTH)

        name = tk.Entry(top)
        name.pack(fill=tk.BOTH)

        def save():
            &#34;&#34;&#34;
            Function for the add button
            &#34;&#34;&#34;
            # recipient name
            x = name.get().rstrip().replace(&#34; &#34;, &#34;&#34;)

            # makes sure there is no duplicates in the treeview
            if x in self.body._messages:
                top.destroy()
            else:
                # insert into treeview
                self.body.insert(x)
                # saves this new contact into DSU file
                saved = SaveData()
                saved.save_into_dsu(self._current_profile.username, &#34;&#34;, x, self._current_profile.password,
                                    self._current_profile.dsuserver, self._profile_filename)
                top.destroy()

        # add button that&#39;s on the popup page
        but = tk.Button(master=top, text=&#34;Add&#34;, width=5)
        but.configure(command=save)
        but.pack(fill=tk.BOTH, side=tk.BOTTOM, padx=5, pady=5)



    def night_on(self):
        &#34;&#34;&#34;
        Method that turns the text widgets dark and texts green
        adapted by youtube codemy.com
        &#34;&#34;&#34;
        maincolor = &#34;#000000&#34;
        secondcolor = &#39;#373737&#39;
        textcolor = &#39;green&#39;

        self.root.config(bg=maincolor)
        self.footer.root.config(bg=maincolor)

        self.body.entry_editor.config(bg=secondcolor, fg=textcolor)
        self.body.send_stuff.config(bg=secondcolor, fg=textcolor)

        self.footer.config(bg=maincolor)


    def night_off(self):
        &#34;&#34;&#34;
        Method that turns the text widget white and the text black
        adapted by youtube codemy.com
        &#34;&#34;&#34;

        maincolor = &#34;SystemButtonFace&#34;
        secondcolor = &#39;SystemButtonFace&#39;
        textcolor = &#39;black&#39;

        self.root.config(bg=maincolor)
        self.footer.root.config(bg=maincolor)

        self.body.entry_editor.config(bg=secondcolor, fg=textcolor)
        self.body.send_stuff.config(bg=secondcolor, fg=textcolor)

        self.footer.config(bg=maincolor)



    def exit_func(self):
        &#34;&#34;&#34;
        Method for closing the threading when we click x button on the window adapted from stackoverflow
        &#34;&#34;&#34;
        self.root.destroy()
        self.control.stop()


    def _draw(self):
        &#34;&#34;&#34;
        Call only once, upon initialization to add widgets to root frame
        &#34;&#34;&#34;
        # Build a menu and add it to the root frame.
        menu_bar = tk.Menu(self.root)
        self.root[&#39;menu&#39;] = menu_bar
        menu_file = tk.Menu(menu_bar)
        menu_bar.add_cascade(menu=menu_file, label=&#39;File&#39;)
        menu_file.add_command(label=&#39;New&#39;, command=self.new_profile)
        menu_file.add_command(label=&#39;Open...&#39;, command=self.open_profile)
        menu_file.add_command(label=&#39;Close&#39;, command=self.close)

        # new menu item for night mode
        menu_file2 = tk.Menu(menu_bar)
        menu_bar.add_cascade(menu=menu_file2, label=&#39;Night Mode&#39;)
        menu_file2.add_command(label=&#39;Night Mode On&#39;, command=self.night_on)
        menu_file2.add_command(label=&#39;Night Mode off&#39;, command=self.night_off)

        # The Body and Footer classes must be initialized and packed into the root window.
        self.body = Body(self.root, self._current_profile)
        self.body.pack(fill=tk.BOTH, side=tk.TOP, expand=True)

        self.footer = Footer(self.root, send_callback=self.save_profile, add_callback=self.add)
        self.footer.pack(fill=tk.BOTH, side=tk.BOTTOM)
        # stops threading even when clicking x button
        # line 577 adapted from stackoverflow
        self.root.protocol(&#39;WM_DELETE_WINDOW&#39;, self.exit_func)


if __name__ == &#34;__main__&#34;:
    # All Tkinter programs start with a root window. We will name ours &#39;main&#39;.
    main = tk.Tk()

    # &#39;title&#39; assigns a text value to the Title Bar area of a window.
    main.title(&#34;ICS 32 Messenger App&#34;)

    # This is just an arbitrary starting point. You can change the value around to see how
    # the starting size of the window changes. I just thought this looked good for our UI.
    main.geometry(&#34;720x700&#34;)

    # adding this option removes some legacy behavior with menus that modern OSes don&#39;t support. 
    # If you&#39;re curious, feel free to comment out and see how the menu changes.
    main.option_add(&#39;*tearOff&#39;, False)

    # Initialize the MainApp class, which is the starting point for the widgets used in the program.
    # All of the classes that we use, subclass Tk.Frame, since our root frame is main, we initialize 
    # the class with it.
    MainApp(main)

    # When update is called, we finalize the states of all widgets that have been configured within the root frame.
    # Here, Update ensures that we get an accurate width and height reading based on the types of widgets
    # we have used.
    # minsize prevents the root window from resizing too small. Feel free to comment it out and see how
    # the resizing behavior of the window changes.
    main.update()
    main.minsize(main.winfo_width(), main.winfo_height())
    # And finally, start up the event loop for the program (more on this in lecture).
    main.mainloop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gui.Body"><code class="flex name class">
<span>class <span class="ident">Body</span></span>
<span>(</span><span>root, select_callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of tk.Frame that is responsible for drawing all of the widgets
in the body portion of the root frame.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Body(tk.Frame):
    &#34;&#34;&#34;
    A subclass of tk.Frame that is responsible for drawing all of the widgets
    in the body portion of the root frame.
    &#34;&#34;&#34;
    def __init__(self, root, select_callback=None):
        tk.Frame.__init__(self, root)
        self.root = root
        self._select_callback = select_callback
        self._file = None

        # a list of the recipients available in the active DSU file
        self._messages = []
        self._recipient = None

        # After all initialization is complete, call the _draw method to pack the widgets
        # into the Body instance
        self._draw()


    def node_select(self, event):
        &#34;&#34;&#34;
        Method for selecting object on treeview and loading the past messages from this recipient into the text widget
        &#34;&#34;&#34;
        self.entry_editor.configure(state=&#39;normal&#39;)
        self.entry_editor.delete(0.0, &#39;end&#39;)
        self.entry_editor.insert(0.0, &#39;&#39;)

        index = int(self.posts_tree.selection()[0])
        entry = self._messages[index]
        # sets the data attribute as the name of the recipient
        self._recipient = entry

        x = SaveData()
        # gets list of message that has occurred between the user and the recipient
        mess = x.re_message_get(self._recipient, self._file)
        if mess is None:
            pass
        else:
            try:
                # loads in the texts depending on if they are the users or the recipients
                for x in mess:
                    if x[-1] == &#39;1&#39;:
                        mes = x[:-1]
                        self.entry_editor.insert(&#39;end&#39;, mes + &#39;\n&#39;, &#39;left&#39;)
                    elif x[-1] == &#39;0&#39;:
                        mes = x[:-1]
                        self.entry_editor.insert(&#39;end&#39;, mes + &#39;\n&#39;, &#39;right&#39;)
                    else:
                        pass
            except IndexError:
                pass
        # return the text widget to read only
        self.entry_editor.configure(state=&#39;disabled&#39;)


    def reset_ui(self):
        &#34;&#34;&#34;
        Method that resets the treeview and the text widget
        &#34;&#34;&#34;
        self.entry_editor.configure(state=&#39;normal&#39;)
        self.entry_editor.delete(0.0, &#39;end&#39;)
        self.entry_editor.insert(0.0, &#39;&#39;)
        self.entry_editor.configure(state=&#39;disabled&#39;)
        self._messages = []
        for item in self.posts_tree.get_children():
            self.posts_tree.delete(item)


    def set_posts(self, name: list):
        &#34;&#34;&#34;
        Method that imports all the recipients in the DSU file into the treeview accoridng to their order
        &#34;&#34;&#34;
        self._messages = name
        for i in range(len(self._messages)):
            self._insert_post_tree(i, self._messages[i])

    def get_text(self):

        &#34;&#34;&#34;
        Method that gets the message that user want to send to a recipient
        &#34;&#34;&#34;
        return self.send_stuff.get(&#39;1.0&#39;, &#39;end&#39;).rstrip()



    def set_text(self, text):
        &#34;&#34;&#34;
        Method that clears the text widget after the user clicks the send button
        &#34;&#34;&#34;
        self.send_stuff.delete(0.0, &#39;end&#39;)
        self.send_stuff.insert(0.0, text)


    def insert(self, name):
        &#34;&#34;&#34;
        Method that inserts a recipient that&#39;s added by the add button into the treeview
        &#34;&#34;&#34;
        self._messages.append(name)
        id = len(self._messages) - 1
        self._insert_post_tree(id, name)



    def _insert_post_tree(self, id, name):
        &#34;&#34;&#34;
        Method that adds to the treeview
        &#34;&#34;&#34;
        label = name
        # Since we don&#39;t have a title, we will use the first 24 characters of a
        # post entry as the identifier in the post_tree widget.
        self.posts_tree.insert(&#39;&#39;, id, id, text=label)


    def _draw(self):
        &#34;&#34;&#34;
        Call only once upon initialization to add widgets to the frame
        &#34;&#34;&#34;
        # treeview widget and frame
        posts_frame = tk.Frame(master=self, width=250)
        posts_frame.pack(fill=tk.BOTH, side=tk.LEFT)
        self.posts_tree = ttk.Treeview(posts_frame)
        self.posts_tree.bind(&#34;&lt;&lt;TreeviewSelect&gt;&gt;&#34;, self.node_select)
        self.posts_tree.pack(fill=tk.BOTH, side=tk.TOP, expand=True, padx=5, pady=5)

        entry_frame = tk.Frame(master=self, bg=&#34;&#34;)
        entry_frame.pack(fill=tk.BOTH, side=tk.TOP, expand=True)

        editor_frame = tk.Frame(master=entry_frame, bg=&#34;red&#34;)
        editor_frame.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        scroll_frame = tk.Frame(master=entry_frame, bg=&#34;blue&#34;, width=10)
        scroll_frame.pack(fill=tk.BOTH, side=tk.LEFT, expand=False)

        # disable the text widget to make it read only
        self.entry_editor = tk.Text(editor_frame, state=&#39;disabled&#39;, width=0)
        self.entry_editor.pack(fill=tk.BOTH, side=tk.LEFT, expand=True, padx=0, pady=0)

        entry_editor_scrollbar = tk.Scrollbar(master=scroll_frame, command=self.entry_editor.yview)
        self.entry_editor[&#39;yscrollcommand&#39;] = entry_editor_scrollbar.set
        entry_editor_scrollbar.pack(fill=tk.Y, side=tk.LEFT, expand=False, padx=0, pady=0)

        # configures the texts in the text widget so that we can make a text appear on the left or right
        # lines 191-192 adapted by stackoverflow on how to display text to the left or right
        self.entry_editor.tag_configure(&#34;right&#34;, justify=&#34;right&#34;)
        self.entry_editor.tag_configure(&#34;left&#34;, justify=&#34;left&#34;)

        # second text widget that is for the user to enter stuff
        entry_frame2 = tk.Frame(master=self, bg=&#34;&#34;)
        entry_frame2.pack(fill=tk.BOTH, side=tk.TOP, expand=True)

        editor_frame2 = tk.Frame(master=entry_frame2, bg=&#34;red&#34;)
        editor_frame2.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        self.send_stuff = tk.Text(master=editor_frame2, width=0)
        self.send_stuff.pack(fill=tk.BOTH, side=tk.LEFT, expand=True, padx=0, pady=0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gui.Body.get_text"><code class="name flex">
<span>def <span class="ident">get_text</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that gets the message that user want to send to a recipient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text(self):

    &#34;&#34;&#34;
    Method that gets the message that user want to send to a recipient
    &#34;&#34;&#34;
    return self.send_stuff.get(&#39;1.0&#39;, &#39;end&#39;).rstrip()</code></pre>
</details>
</dd>
<dt id="gui.Body.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that inserts a recipient that's added by the add button into the treeview</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, name):
    &#34;&#34;&#34;
    Method that inserts a recipient that&#39;s added by the add button into the treeview
    &#34;&#34;&#34;
    self._messages.append(name)
    id = len(self._messages) - 1
    self._insert_post_tree(id, name)</code></pre>
</details>
</dd>
<dt id="gui.Body.node_select"><code class="name flex">
<span>def <span class="ident">node_select</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for selecting object on treeview and loading the past messages from this recipient into the text widget</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_select(self, event):
    &#34;&#34;&#34;
    Method for selecting object on treeview and loading the past messages from this recipient into the text widget
    &#34;&#34;&#34;
    self.entry_editor.configure(state=&#39;normal&#39;)
    self.entry_editor.delete(0.0, &#39;end&#39;)
    self.entry_editor.insert(0.0, &#39;&#39;)

    index = int(self.posts_tree.selection()[0])
    entry = self._messages[index]
    # sets the data attribute as the name of the recipient
    self._recipient = entry

    x = SaveData()
    # gets list of message that has occurred between the user and the recipient
    mess = x.re_message_get(self._recipient, self._file)
    if mess is None:
        pass
    else:
        try:
            # loads in the texts depending on if they are the users or the recipients
            for x in mess:
                if x[-1] == &#39;1&#39;:
                    mes = x[:-1]
                    self.entry_editor.insert(&#39;end&#39;, mes + &#39;\n&#39;, &#39;left&#39;)
                elif x[-1] == &#39;0&#39;:
                    mes = x[:-1]
                    self.entry_editor.insert(&#39;end&#39;, mes + &#39;\n&#39;, &#39;right&#39;)
                else:
                    pass
        except IndexError:
            pass
    # return the text widget to read only
    self.entry_editor.configure(state=&#39;disabled&#39;)</code></pre>
</details>
</dd>
<dt id="gui.Body.reset_ui"><code class="name flex">
<span>def <span class="ident">reset_ui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that resets the treeview and the text widget</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_ui(self):
    &#34;&#34;&#34;
    Method that resets the treeview and the text widget
    &#34;&#34;&#34;
    self.entry_editor.configure(state=&#39;normal&#39;)
    self.entry_editor.delete(0.0, &#39;end&#39;)
    self.entry_editor.insert(0.0, &#39;&#39;)
    self.entry_editor.configure(state=&#39;disabled&#39;)
    self._messages = []
    for item in self.posts_tree.get_children():
        self.posts_tree.delete(item)</code></pre>
</details>
</dd>
<dt id="gui.Body.set_posts"><code class="name flex">
<span>def <span class="ident">set_posts</span></span>(<span>self, name: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that imports all the recipients in the DSU file into the treeview accoridng to their order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_posts(self, name: list):
    &#34;&#34;&#34;
    Method that imports all the recipients in the DSU file into the treeview accoridng to their order
    &#34;&#34;&#34;
    self._messages = name
    for i in range(len(self._messages)):
        self._insert_post_tree(i, self._messages[i])</code></pre>
</details>
</dd>
<dt id="gui.Body.set_text"><code class="name flex">
<span>def <span class="ident">set_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that clears the text widget after the user clicks the send button</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text(self, text):
    &#34;&#34;&#34;
    Method that clears the text widget after the user clicks the send button
    &#34;&#34;&#34;
    self.send_stuff.delete(0.0, &#39;end&#39;)
    self.send_stuff.insert(0.0, text)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gui.Footer"><code class="flex name class">
<span>class <span class="ident">Footer</span></span>
<span>(</span><span>root, send_callback=None, add_callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of tk.Frame that is responsible for drawing all of the widgets
in the footer portion of the root frame.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Footer(tk.Frame):
    &#34;&#34;&#34;
    A subclass of tk.Frame that is responsible for drawing all of the widgets
    in the footer portion of the root frame.
    &#34;&#34;&#34;
    def __init__(self, root, send_callback=None, add_callback=None):
        tk.Frame.__init__(self, root)
        self.root = root
        # sets data attributes with the parameters
        self._send_callback = send_callback
        self._add_callback = add_callback

        # After all initialization is complete, call the _draw method to pack the widgets
        # into the Footer instance
        self._draw()


    def send_click(self):
        &#34;&#34;&#34;
        Calls the callback function specified in the send_callback class attribute, if
        available, when the send_button has been clicked.
        &#34;&#34;&#34;

        if self._send_callback is not None:
            self._send_callback()


    def add_click(self):
        &#34;&#34;&#34;
        Calls the callback function specified in the add_callback class attribute, if
        available, when the add_button widget has been clicked.
        &#34;&#34;&#34;
        if self._add_callback is not None:
            self._add_callback()


    def disable(self):
        &#34;&#34;&#34;
        Disables the send and add button if nothing is created or opened
        &#34;&#34;&#34;
        self.send_button[&#34;state&#34;] = &#34;disabled&#34;
        self.add_button[&#34;state&#34;] = &#34;disabled&#34;



    def enable(self):
        &#34;&#34;&#34;
        Enables the send and add button after a file is created or opened
        &#34;&#34;&#34;
        self.send_button[&#34;state&#34;] = &#34;active&#34;
        self.add_button[&#34;state&#34;] = &#34;active&#34;



    def _draw(self):
        &#34;&#34;&#34;
        Call only once upon initialization to add widgets to the frame
        &#34;&#34;&#34;
        # send button
        self.send_button = tk.Button(master=self, text=&#34;Send&#34;, width=20)
        self.send_button.configure(command=self.send_click)
        self.send_button.pack(fill=tk.BOTH, side=tk.RIGHT, padx=5, pady=5)

        # add user button
        self.add_button = tk.Button(master=self, text=&#34;Add User&#34;, width=10)
        self.add_button.configure(command=self.add_click)
        self.add_button.pack(fill=tk.BOTH, side=tk.LEFT, padx=5, pady=5)

        # disables the buttons
        self.disable()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gui.Footer.add_click"><code class="name flex">
<span>def <span class="ident">add_click</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls the callback function specified in the add_callback class attribute, if
available, when the add_button widget has been clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_click(self):
    &#34;&#34;&#34;
    Calls the callback function specified in the add_callback class attribute, if
    available, when the add_button widget has been clicked.
    &#34;&#34;&#34;
    if self._add_callback is not None:
        self._add_callback()</code></pre>
</details>
</dd>
<dt id="gui.Footer.disable"><code class="name flex">
<span>def <span class="ident">disable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the send and add button if nothing is created or opened</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable(self):
    &#34;&#34;&#34;
    Disables the send and add button if nothing is created or opened
    &#34;&#34;&#34;
    self.send_button[&#34;state&#34;] = &#34;disabled&#34;
    self.add_button[&#34;state&#34;] = &#34;disabled&#34;</code></pre>
</details>
</dd>
<dt id="gui.Footer.enable"><code class="name flex">
<span>def <span class="ident">enable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the send and add button after a file is created or opened</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable(self):
    &#34;&#34;&#34;
    Enables the send and add button after a file is created or opened
    &#34;&#34;&#34;
    self.send_button[&#34;state&#34;] = &#34;active&#34;
    self.add_button[&#34;state&#34;] = &#34;active&#34;</code></pre>
</details>
</dd>
<dt id="gui.Footer.send_click"><code class="name flex">
<span>def <span class="ident">send_click</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls the callback function specified in the send_callback class attribute, if
available, when the send_button has been clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_click(self):
    &#34;&#34;&#34;
    Calls the callback function specified in the send_callback class attribute, if
    available, when the send_button has been clicked.
    &#34;&#34;&#34;

    if self._send_callback is not None:
        self._send_callback()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gui.MainApp"><code class="flex name class">
<span>class <span class="ident">MainApp</span></span>
<span>(</span><span>root)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of tk.Frame that is responsible for drawing all of the widgets
in the main portion of the root frame. Also manages all method calls for
the Profile class.</p>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainApp(tk.Frame):
    &#34;&#34;&#34;
    A subclass of tk.Frame that is responsible for drawing all of the widgets
    in the main portion of the root frame. Also manages all method calls for
    the Profile class.
    &#34;&#34;&#34;
    def __init__(self, root):
        tk.Frame.__init__(self, root)
        self.root = root
        self._profile_filename = None

        # Initialize a new Profile and assign it to a class attribute.
        self._current_profile = Profile()

        # After all initialization is complete, call the _draw method to pack the widgets
        # into the root frame
        self._draw()



    def new_profile(self):
        &#34;&#34;&#34;
        Creates a new DSU file when the &#39;New&#39; menu item is clicked.
        &#34;&#34;&#34;
        try:
            filename = tk.filedialog.asksaveasfile(filetypes=[(&#39;Distributed Social Profile&#39;, &#39;*.dsu&#39;)])
            self._profile_filename = filename.name
            self.body._file = self._profile_filename

            # enables the buttons
            self.footer.enable()

            self._current_profile = Profile()
            # assigns the default values to these data attributes
            self._current_profile.username = USER
            self._current_profile.password = PASS
            self._current_profile.dsuserver = SERVER
            self.body.reset_ui()

            # calls the function that automatically retrieves messages
            # creates repeatedtimer object
            rt = RepeatedTimer(2.5, self.new_msg)
            self.control = rt


        except Exception as e:
            print(e)


    def open_profile(self):
        &#34;&#34;&#34;
        Opens an existing DSU file when the &#39;Open&#39; menu item is clicked and loads the profile
        data into the UI.
        &#34;&#34;&#34;
        try:
            # reset treeview and entry widget when it is called
            self.body.reset_ui()

            filename = tk.filedialog.askopenfile(filetypes=[(&#39;Distributed Social Profile&#39;, &#39;*.dsu&#39;)])
            self._profile_filename = filename.name
            self.body._file = self._profile_filename

            # enables the buttons
            self.footer.enable()

            self._current_profile = Profile()

            x = SaveData()
            y = x.return_user_pass(self._profile_filename)
            # gets the user, pass, dsuserver from the DSU file
            self._current_profile.username = y[0]
            self._current_profile.password = y[1]
            self._current_profile.dsuserver = y[2]

            # imports the messages into the treeview
            self.body.set_posts(x.open_mes(self._profile_filename))
            # calls the function that automatically retrieves new messages
            # creates repeatedtimer object
            rt = RepeatedTimer(2.5, self.new_msg)
            self.control = rt


        except Exception as e:
            print(e)


    def save_profile(self):
        &#34;&#34;&#34;
        Method that sends the direct message once the send button is clicked and also saves it to the dsu file
        &#34;&#34;&#34;
        # makes sure user can&#39;t send in empty messages or whitespaces
        if len(self.body.get_text()) == 0 or self.body.get_text().isspace() is True:
            pass
        else:
            # makes sure a user selected a recipient to talk to
            if self.body._recipient is None:
                print(&#39;select user to talk to&#39;)
            else:
                message = self.body.get_text()

                # creates instances of the classes
                exchange = ms.DirectMessage(self.body._recipient, message)
                more = ms.DirectMessenger(self._current_profile.dsuserver, self._current_profile.username,
                                          self._current_profile.password)
                # makes sure the send method worked
                if more.send(exchange.message, exchange.recipient) is True:

                    # inserts the text into the read only text widget once the send button is clicked
                    self.body.set_text(&#34;&#34;)
                    self.body.entry_editor.configure(state=&#39;normal&#39;)
                    self.body.entry_editor.insert(&#39;end&#39;, message + &#39;\n&#39;, &#39;right&#39;)
                    self.body.entry_editor.configure(state=&#39;disabled&#39;)

                    # stores the text into the DSU file
                    message = message + &#39;0&#39;
                    x = SaveData()
                    x.save_into_dsu(self._current_profile.username, message, self.body._recipient,
                                    self._current_profile.password, self._current_profile.dsuserver,
                                    self._profile_filename)
                    self.body.set_text(&#34;&#34;)
                else:
                    print(&#39;issue occurred with server or network&#39;)


    def new_msg(self):
        &#34;&#34;&#34;
        Method that keeps connecting to the server every 3 seconds to receive new messages that might be sent
        &#34;&#34;&#34;
        try:
            exchange = ms.DirectMessenger(self._current_profile.dsuserver, self._current_profile.username,
                                          self._current_profile.password)
            # gets list of all new messages
            list1 = exchange.retrieve_new()

            # makes sure there is new messages
            if len(list1) &gt; 0:
                for x in list1:
                    # checks if the user has clicked on a treeview item yet
                    if self.body._recipient is not None:

                        # checks if the message that&#39;s sent is from the recipient they clicked on
                        if x[&#39;from&#39;] == self.body._recipient:
                            # inserts the message to the read only text widget
                            self.body.entry_editor.configure(state=&#39;normal&#39;)
                            self.body.entry_editor.insert(&#39;end&#39;, x[&#39;message&#39;] + &#39;\n&#39;, &#39;left&#39;)
                            self.body.entry_editor.configure(state=&#39;disabled&#39;)
                            # saves message to the DSU file
                            message = x[&#39;message&#39;] + &#39;1&#39;
                            x = SaveData()
                            x.save_into_dsu(self._current_profile.username, message, self.body._recipient,
                                            self._current_profile.password, self._current_profile.dsuserver,
                                            self._profile_filename)
                        # if the message that&#39;s sent is not from the recipient they clicked on
                        else:
                            message = x[&#39;message&#39;] + &#39;1&#39;
                            l = x[&#39;from&#39;]
                            x = SaveData()
                            x.save_into_dsu(self._current_profile.username, message, l,
                                            self._current_profile.password, self._current_profile.dsuserver,
                                            self._profile_filename)
                    # if the user has not clicked on a recipient yet
                    else:
                        message = x[&#39;message&#39;] + &#39;1&#39;
                        l = x[&#39;from&#39;]
                        x = SaveData()
                        x.save_into_dsu(self._current_profile.username, message, l,
                                        self._current_profile.password, self._current_profile.dsuserver,
                                        self._profile_filename)

            else:
                pass
        except:
            print(&#39;Something occurred with the server and network&#39;)



    def close(self):
        &#34;&#34;&#34;
        Closes the program when the &#39;Close&#39; menu item is clicked.
        &#34;&#34;&#34;
        self.root.destroy()
        self.control.stop()


    def add(self):
        &#34;&#34;&#34;
        Method that runs when the add button is clicked
        &#34;&#34;&#34;
        # add user to the tree
        top = tk.Toplevel()
        top.title(&#39;Add User&#39;)
        user = tk.Label(top, text=&#34;Add Contact:&#34;)
        user.pack(fill=tk.BOTH)

        name = tk.Entry(top)
        name.pack(fill=tk.BOTH)

        def save():
            &#34;&#34;&#34;
            Function for the add button
            &#34;&#34;&#34;
            # recipient name
            x = name.get().rstrip().replace(&#34; &#34;, &#34;&#34;)

            # makes sure there is no duplicates in the treeview
            if x in self.body._messages:
                top.destroy()
            else:
                # insert into treeview
                self.body.insert(x)
                # saves this new contact into DSU file
                saved = SaveData()
                saved.save_into_dsu(self._current_profile.username, &#34;&#34;, x, self._current_profile.password,
                                    self._current_profile.dsuserver, self._profile_filename)
                top.destroy()

        # add button that&#39;s on the popup page
        but = tk.Button(master=top, text=&#34;Add&#34;, width=5)
        but.configure(command=save)
        but.pack(fill=tk.BOTH, side=tk.BOTTOM, padx=5, pady=5)



    def night_on(self):
        &#34;&#34;&#34;
        Method that turns the text widgets dark and texts green
        adapted by youtube codemy.com
        &#34;&#34;&#34;
        maincolor = &#34;#000000&#34;
        secondcolor = &#39;#373737&#39;
        textcolor = &#39;green&#39;

        self.root.config(bg=maincolor)
        self.footer.root.config(bg=maincolor)

        self.body.entry_editor.config(bg=secondcolor, fg=textcolor)
        self.body.send_stuff.config(bg=secondcolor, fg=textcolor)

        self.footer.config(bg=maincolor)


    def night_off(self):
        &#34;&#34;&#34;
        Method that turns the text widget white and the text black
        adapted by youtube codemy.com
        &#34;&#34;&#34;

        maincolor = &#34;SystemButtonFace&#34;
        secondcolor = &#39;SystemButtonFace&#39;
        textcolor = &#39;black&#39;

        self.root.config(bg=maincolor)
        self.footer.root.config(bg=maincolor)

        self.body.entry_editor.config(bg=secondcolor, fg=textcolor)
        self.body.send_stuff.config(bg=secondcolor, fg=textcolor)

        self.footer.config(bg=maincolor)



    def exit_func(self):
        &#34;&#34;&#34;
        Method for closing the threading when we click x button on the window adapted from stackoverflow
        &#34;&#34;&#34;
        self.root.destroy()
        self.control.stop()


    def _draw(self):
        &#34;&#34;&#34;
        Call only once, upon initialization to add widgets to root frame
        &#34;&#34;&#34;
        # Build a menu and add it to the root frame.
        menu_bar = tk.Menu(self.root)
        self.root[&#39;menu&#39;] = menu_bar
        menu_file = tk.Menu(menu_bar)
        menu_bar.add_cascade(menu=menu_file, label=&#39;File&#39;)
        menu_file.add_command(label=&#39;New&#39;, command=self.new_profile)
        menu_file.add_command(label=&#39;Open...&#39;, command=self.open_profile)
        menu_file.add_command(label=&#39;Close&#39;, command=self.close)

        # new menu item for night mode
        menu_file2 = tk.Menu(menu_bar)
        menu_bar.add_cascade(menu=menu_file2, label=&#39;Night Mode&#39;)
        menu_file2.add_command(label=&#39;Night Mode On&#39;, command=self.night_on)
        menu_file2.add_command(label=&#39;Night Mode off&#39;, command=self.night_off)

        # The Body and Footer classes must be initialized and packed into the root window.
        self.body = Body(self.root, self._current_profile)
        self.body.pack(fill=tk.BOTH, side=tk.TOP, expand=True)

        self.footer = Footer(self.root, send_callback=self.save_profile, add_callback=self.add)
        self.footer.pack(fill=tk.BOTH, side=tk.BOTTOM)
        # stops threading even when clicking x button
        # line 577 adapted from stackoverflow
        self.root.protocol(&#39;WM_DELETE_WINDOW&#39;, self.exit_func)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gui.MainApp.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that runs when the add button is clicked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self):
    &#34;&#34;&#34;
    Method that runs when the add button is clicked
    &#34;&#34;&#34;
    # add user to the tree
    top = tk.Toplevel()
    top.title(&#39;Add User&#39;)
    user = tk.Label(top, text=&#34;Add Contact:&#34;)
    user.pack(fill=tk.BOTH)

    name = tk.Entry(top)
    name.pack(fill=tk.BOTH)

    def save():
        &#34;&#34;&#34;
        Function for the add button
        &#34;&#34;&#34;
        # recipient name
        x = name.get().rstrip().replace(&#34; &#34;, &#34;&#34;)

        # makes sure there is no duplicates in the treeview
        if x in self.body._messages:
            top.destroy()
        else:
            # insert into treeview
            self.body.insert(x)
            # saves this new contact into DSU file
            saved = SaveData()
            saved.save_into_dsu(self._current_profile.username, &#34;&#34;, x, self._current_profile.password,
                                self._current_profile.dsuserver, self._profile_filename)
            top.destroy()

    # add button that&#39;s on the popup page
    but = tk.Button(master=top, text=&#34;Add&#34;, width=5)
    but.configure(command=save)
    but.pack(fill=tk.BOTH, side=tk.BOTTOM, padx=5, pady=5)</code></pre>
</details>
</dd>
<dt id="gui.MainApp.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the program when the 'Close' menu item is clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Closes the program when the &#39;Close&#39; menu item is clicked.
    &#34;&#34;&#34;
    self.root.destroy()
    self.control.stop()</code></pre>
</details>
</dd>
<dt id="gui.MainApp.exit_func"><code class="name flex">
<span>def <span class="ident">exit_func</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for closing the threading when we click x button on the window adapted from stackoverflow</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_func(self):
    &#34;&#34;&#34;
    Method for closing the threading when we click x button on the window adapted from stackoverflow
    &#34;&#34;&#34;
    self.root.destroy()
    self.control.stop()</code></pre>
</details>
</dd>
<dt id="gui.MainApp.new_msg"><code class="name flex">
<span>def <span class="ident">new_msg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that keeps connecting to the server every 3 seconds to receive new messages that might be sent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_msg(self):
    &#34;&#34;&#34;
    Method that keeps connecting to the server every 3 seconds to receive new messages that might be sent
    &#34;&#34;&#34;
    try:
        exchange = ms.DirectMessenger(self._current_profile.dsuserver, self._current_profile.username,
                                      self._current_profile.password)
        # gets list of all new messages
        list1 = exchange.retrieve_new()

        # makes sure there is new messages
        if len(list1) &gt; 0:
            for x in list1:
                # checks if the user has clicked on a treeview item yet
                if self.body._recipient is not None:

                    # checks if the message that&#39;s sent is from the recipient they clicked on
                    if x[&#39;from&#39;] == self.body._recipient:
                        # inserts the message to the read only text widget
                        self.body.entry_editor.configure(state=&#39;normal&#39;)
                        self.body.entry_editor.insert(&#39;end&#39;, x[&#39;message&#39;] + &#39;\n&#39;, &#39;left&#39;)
                        self.body.entry_editor.configure(state=&#39;disabled&#39;)
                        # saves message to the DSU file
                        message = x[&#39;message&#39;] + &#39;1&#39;
                        x = SaveData()
                        x.save_into_dsu(self._current_profile.username, message, self.body._recipient,
                                        self._current_profile.password, self._current_profile.dsuserver,
                                        self._profile_filename)
                    # if the message that&#39;s sent is not from the recipient they clicked on
                    else:
                        message = x[&#39;message&#39;] + &#39;1&#39;
                        l = x[&#39;from&#39;]
                        x = SaveData()
                        x.save_into_dsu(self._current_profile.username, message, l,
                                        self._current_profile.password, self._current_profile.dsuserver,
                                        self._profile_filename)
                # if the user has not clicked on a recipient yet
                else:
                    message = x[&#39;message&#39;] + &#39;1&#39;
                    l = x[&#39;from&#39;]
                    x = SaveData()
                    x.save_into_dsu(self._current_profile.username, message, l,
                                    self._current_profile.password, self._current_profile.dsuserver,
                                    self._profile_filename)

        else:
            pass
    except:
        print(&#39;Something occurred with the server and network&#39;)</code></pre>
</details>
</dd>
<dt id="gui.MainApp.new_profile"><code class="name flex">
<span>def <span class="ident">new_profile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new DSU file when the 'New' menu item is clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_profile(self):
    &#34;&#34;&#34;
    Creates a new DSU file when the &#39;New&#39; menu item is clicked.
    &#34;&#34;&#34;
    try:
        filename = tk.filedialog.asksaveasfile(filetypes=[(&#39;Distributed Social Profile&#39;, &#39;*.dsu&#39;)])
        self._profile_filename = filename.name
        self.body._file = self._profile_filename

        # enables the buttons
        self.footer.enable()

        self._current_profile = Profile()
        # assigns the default values to these data attributes
        self._current_profile.username = USER
        self._current_profile.password = PASS
        self._current_profile.dsuserver = SERVER
        self.body.reset_ui()

        # calls the function that automatically retrieves messages
        # creates repeatedtimer object
        rt = RepeatedTimer(2.5, self.new_msg)
        self.control = rt


    except Exception as e:
        print(e)</code></pre>
</details>
</dd>
<dt id="gui.MainApp.night_off"><code class="name flex">
<span>def <span class="ident">night_off</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that turns the text widget white and the text black
adapted by youtube codemy.com</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def night_off(self):
    &#34;&#34;&#34;
    Method that turns the text widget white and the text black
    adapted by youtube codemy.com
    &#34;&#34;&#34;

    maincolor = &#34;SystemButtonFace&#34;
    secondcolor = &#39;SystemButtonFace&#39;
    textcolor = &#39;black&#39;

    self.root.config(bg=maincolor)
    self.footer.root.config(bg=maincolor)

    self.body.entry_editor.config(bg=secondcolor, fg=textcolor)
    self.body.send_stuff.config(bg=secondcolor, fg=textcolor)

    self.footer.config(bg=maincolor)</code></pre>
</details>
</dd>
<dt id="gui.MainApp.night_on"><code class="name flex">
<span>def <span class="ident">night_on</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that turns the text widgets dark and texts green
adapted by youtube codemy.com</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def night_on(self):
    &#34;&#34;&#34;
    Method that turns the text widgets dark and texts green
    adapted by youtube codemy.com
    &#34;&#34;&#34;
    maincolor = &#34;#000000&#34;
    secondcolor = &#39;#373737&#39;
    textcolor = &#39;green&#39;

    self.root.config(bg=maincolor)
    self.footer.root.config(bg=maincolor)

    self.body.entry_editor.config(bg=secondcolor, fg=textcolor)
    self.body.send_stuff.config(bg=secondcolor, fg=textcolor)

    self.footer.config(bg=maincolor)</code></pre>
</details>
</dd>
<dt id="gui.MainApp.open_profile"><code class="name flex">
<span>def <span class="ident">open_profile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens an existing DSU file when the 'Open' menu item is clicked and loads the profile
data into the UI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_profile(self):
    &#34;&#34;&#34;
    Opens an existing DSU file when the &#39;Open&#39; menu item is clicked and loads the profile
    data into the UI.
    &#34;&#34;&#34;
    try:
        # reset treeview and entry widget when it is called
        self.body.reset_ui()

        filename = tk.filedialog.askopenfile(filetypes=[(&#39;Distributed Social Profile&#39;, &#39;*.dsu&#39;)])
        self._profile_filename = filename.name
        self.body._file = self._profile_filename

        # enables the buttons
        self.footer.enable()

        self._current_profile = Profile()

        x = SaveData()
        y = x.return_user_pass(self._profile_filename)
        # gets the user, pass, dsuserver from the DSU file
        self._current_profile.username = y[0]
        self._current_profile.password = y[1]
        self._current_profile.dsuserver = y[2]

        # imports the messages into the treeview
        self.body.set_posts(x.open_mes(self._profile_filename))
        # calls the function that automatically retrieves new messages
        # creates repeatedtimer object
        rt = RepeatedTimer(2.5, self.new_msg)
        self.control = rt


    except Exception as e:
        print(e)</code></pre>
</details>
</dd>
<dt id="gui.MainApp.save_profile"><code class="name flex">
<span>def <span class="ident">save_profile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that sends the direct message once the send button is clicked and also saves it to the dsu file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_profile(self):
    &#34;&#34;&#34;
    Method that sends the direct message once the send button is clicked and also saves it to the dsu file
    &#34;&#34;&#34;
    # makes sure user can&#39;t send in empty messages or whitespaces
    if len(self.body.get_text()) == 0 or self.body.get_text().isspace() is True:
        pass
    else:
        # makes sure a user selected a recipient to talk to
        if self.body._recipient is None:
            print(&#39;select user to talk to&#39;)
        else:
            message = self.body.get_text()

            # creates instances of the classes
            exchange = ms.DirectMessage(self.body._recipient, message)
            more = ms.DirectMessenger(self._current_profile.dsuserver, self._current_profile.username,
                                      self._current_profile.password)
            # makes sure the send method worked
            if more.send(exchange.message, exchange.recipient) is True:

                # inserts the text into the read only text widget once the send button is clicked
                self.body.set_text(&#34;&#34;)
                self.body.entry_editor.configure(state=&#39;normal&#39;)
                self.body.entry_editor.insert(&#39;end&#39;, message + &#39;\n&#39;, &#39;right&#39;)
                self.body.entry_editor.configure(state=&#39;disabled&#39;)

                # stores the text into the DSU file
                message = message + &#39;0&#39;
                x = SaveData()
                x.save_into_dsu(self._current_profile.username, message, self.body._recipient,
                                self._current_profile.password, self._current_profile.dsuserver,
                                self._profile_filename)
                self.body.set_text(&#34;&#34;)
            else:
                print(&#39;issue occurred with server or network&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gui.RepeatedTimer"><code class="flex name class">
<span>class <span class="ident">RepeatedTimer</span></span>
<span>(</span><span>interval, function, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeat <code>function</code> every <code>interval</code> seconds. Adapted from stackoverflow for stopping threading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RepeatedTimer:

    &#34;&#34;&#34;Repeat `function` every `interval` seconds. Adapted from stackoverflow for stopping threading&#34;&#34;&#34;

    def __init__(self, interval, function, *args, **kwargs):
        self.interval = interval
        self.function = function
        self.args = args
        self.kwargs = kwargs
        self.start = time.time()
        self.event = Event()
        self.thread = Thread(target=self._target)
        self.thread.start()

    def _target(self):
        while not self.event.wait(self._time):
            self.function(*self.args, **self.kwargs)

    @property
    def _time(self):
        return self.interval - ((time.time() - self.start) % self.interval)

    def stop(self):
        self.event.set()
        self.thread.join()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gui.RepeatedTimer.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.event.set()
    self.thread.join()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gui.Body" href="#gui.Body">Body</a></code></h4>
<ul class="two-column">
<li><code><a title="gui.Body.get_text" href="#gui.Body.get_text">get_text</a></code></li>
<li><code><a title="gui.Body.insert" href="#gui.Body.insert">insert</a></code></li>
<li><code><a title="gui.Body.node_select" href="#gui.Body.node_select">node_select</a></code></li>
<li><code><a title="gui.Body.reset_ui" href="#gui.Body.reset_ui">reset_ui</a></code></li>
<li><code><a title="gui.Body.set_posts" href="#gui.Body.set_posts">set_posts</a></code></li>
<li><code><a title="gui.Body.set_text" href="#gui.Body.set_text">set_text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gui.Footer" href="#gui.Footer">Footer</a></code></h4>
<ul class="">
<li><code><a title="gui.Footer.add_click" href="#gui.Footer.add_click">add_click</a></code></li>
<li><code><a title="gui.Footer.disable" href="#gui.Footer.disable">disable</a></code></li>
<li><code><a title="gui.Footer.enable" href="#gui.Footer.enable">enable</a></code></li>
<li><code><a title="gui.Footer.send_click" href="#gui.Footer.send_click">send_click</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gui.MainApp" href="#gui.MainApp">MainApp</a></code></h4>
<ul class="two-column">
<li><code><a title="gui.MainApp.add" href="#gui.MainApp.add">add</a></code></li>
<li><code><a title="gui.MainApp.close" href="#gui.MainApp.close">close</a></code></li>
<li><code><a title="gui.MainApp.exit_func" href="#gui.MainApp.exit_func">exit_func</a></code></li>
<li><code><a title="gui.MainApp.new_msg" href="#gui.MainApp.new_msg">new_msg</a></code></li>
<li><code><a title="gui.MainApp.new_profile" href="#gui.MainApp.new_profile">new_profile</a></code></li>
<li><code><a title="gui.MainApp.night_off" href="#gui.MainApp.night_off">night_off</a></code></li>
<li><code><a title="gui.MainApp.night_on" href="#gui.MainApp.night_on">night_on</a></code></li>
<li><code><a title="gui.MainApp.open_profile" href="#gui.MainApp.open_profile">open_profile</a></code></li>
<li><code><a title="gui.MainApp.save_profile" href="#gui.MainApp.save_profile">save_profile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gui.RepeatedTimer" href="#gui.RepeatedTimer">RepeatedTimer</a></code></h4>
<ul class="">
<li><code><a title="gui.RepeatedTimer.stop" href="#gui.RepeatedTimer.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>